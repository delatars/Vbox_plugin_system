# -*- coding: utf-8 -*-
import os
import shutil
import socket
from collections import namedtuple
from vmaker.utils.logger import STREAM
from vmaker.init.settings import LoadSettings
from vmaker.utils.auxilary import exception_interceptor
from vmaker.keywords.port_forwarding import get_manage_port

from ansible.parsing.dataloader import DataLoader
from ansible.vars.manager import VariableManager
from ansible.inventory.manager import InventoryManager
from ansible.executor.playbook_executor import PlaybookExecutor
import ansible.constants as C


class Keyword:
    """ This class represents the keyword's template """
    REQUIRED_CONFIG_ATTRS = ["vm_name", "ansible_playbooks", "ansible_inventory_options"]
    ANSIBLE_SERVER = "localhost"
    ANSIBLE_PORT = None
    CONNECTION_TIMEOUT = 30

    @exception_interceptor
    def main(self):
        """ Mandatory method, invoked by vmaker Core process, which represents an entrypoint of the keyword. """
        # - Attributes taken from vmaker user config
        self.vm_name = self.vm_name
        self.ansible_playbooks = self.ansible_playbooks
        self.ansible_inventory_options = self.ansible_inventory_options
        # ----------------------------------
        self.ANSIBLE_PORT = get_manage_port(self.vm_name)
        self.check_connection()
        playbooks = self.parse_playbooks()
        inventory = self.create_inventory()
        # We will run playbooks one by one to make it easier to detect the problems
        for playbook in playbooks:
            self.run_playbook(playbook, inventory)

    def _port_check(self, ip, port):
        conn = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        conn.settimeout(5)
        try:
            conn.connect((ip, port))
            return True
        except:
            return False
        finally:
            conn.close()

    def check_connection(self):
        STREAM.info("==> Waiting for the availability of the port: %s:%s" % (self.ANSIBLE_SERVER, self.ANSIBLE_PORT))
        attempt = 0
        while True:
            if self._port_check(self.ANSIBLE_SERVER, self.ANSIBLE_PORT):
                STREAM.info(" -> Port available.")
                break
            if attempt == self.CONNECTION_TIMEOUT//5:
                STREAM.error(" -> Port unavailable.")
                break

    def create_inventory(self):
        STREAM.debug(" -> ---------- Inventory.")
        inventory_options = {}
        inventory_file = os.path.join(LoadSettings.WORK_DIR, ".ansible_inventory")
        options = [option.strip().replace(" ", "_") for option in self.ansible_inventory_options.split(",")]
        for option in options:
            inventory_options = dict(inventory_options, **dict([option.split(":")]))
        STREAM.debug(" -> User inventory options: %s" % inventory_options)
        inventory_options.pop("ansible_host", None)
        inventory_options.pop("ansible_port", None)
        extra_options = " ".join(["%s=%s" % (opt, val) for (opt, val) in inventory_options.items()])
        with open(inventory_file, "w") as inventory:
            inventory.write("# Generated by vmaker\n\nvmaker ansible_host=%s ansible_port=%s %s\n" %
                            (self.ANSIBLE_SERVER, self.ANSIBLE_PORT, extra_options))
        STREAM.debug(" -> Created inventory file: %s" % inventory_file)
        return inventory_file

    def parse_options(self):
        STREAM.debug(" -> ---------- Options.")
        options = {
            'listtags': False,
            'listtasks': False,
            'listhosts': False,
            'syntax': False,
            'connection': 'smart',
            'module_path': None,
            'forks': 10,
            'become': None,
            'become_method': None,
            'become_user': None,
            'check': False,
            'diff': False,
            'private_key_file': None,
            'ssh_common_args': None,
            'ssh_extra_args': None,
            'sftp_extra_args': None,
            'scp_extra_args': None,
            'verbosity': None
        }
        ansible_kwargs = {attr[8:]: getattr(self, attr) for attr in dir(self)
                          if attr.startswith('ansible_') and not attr.startswith('_')
                          and not attr == "ansible_playbooks"
                          and not attr == "ansible_inventory_options"}
        user_can_change = ['connection', 'module_path', 'become', 'become_method',
                           'become_user', 'check', 'diff', 'private_key_file',
                           'ssh_common_args', 'ssh_extra_args', 'sftp_extra_args',
                           'scp_extra_args', 'verbosity']
        STREAM.debug(" -> Options that user allowed to change: ")
        map(lambda x: STREAM.debug("  - %s" % x), user_can_change)
        STREAM.debug(" -> User changed: %s" % ansible_kwargs)
        for key, val in ansible_kwargs.items():
            if key not in user_can_change:
                continue
            if val.lower() == "true":
                options[key] = True
            elif val.lower() == "false":
                options[key] = False
            try:
                options[key] = int(val)
            except ValueError:
                options[key] = val
        STREAM.debug(" -> Result options: %s" % options)
        Options = namedtuple('Options', ['listtags', 'listtasks', 'listhosts', 'syntax', 'connection', 'module_path',
                                         'forks', 'private_key_file', 'ssh_common_args', 'ssh_extra_args',
                                         'sftp_extra_args', 'scp_extra_args', 'become', 'become_method',
                                         'become_user', 'verbosity', 'check', 'diff'])
        return Options(**options)

    def parse_playbooks(self):
        STREAM.debug(" -> ---------- Playbooks.")
        ansible_playbooks = [playbook.strip() for playbook in self.ansible_playbooks.split(",")]
        STREAM.debug(" -> Playbooks: %s" % ansible_playbooks)
        for playbook in ansible_playbooks:
            if not os.path.exists(playbook):
                raise Exception("the playbook: %s could not be found" % playbook)
            if not os.path.isfile(playbook):
                raise Exception("the playbook: %s does not appear to be a file" % playbook)
        return ansible_playbooks

    def run_playbook(self, playbook, inventory):
        options = self.parse_options()
        STREAM.info("==> Execute Ansible playbook: %s" % playbook)
        # initialize needed objects
        loader = DataLoader()
        passwords = {}
        inventory = InventoryManager(loader=loader, sources=inventory)
        variable_manager = VariableManager(loader=loader, inventory=inventory)
        # create the playbook executor, which manages running the plays via a task queue manager
        pbex = PlaybookExecutor(playbooks=[playbook], inventory=inventory, variable_manager=variable_manager,
                                loader=loader, options=options, passwords=passwords)
        # run playbook and return exit_code
        results = pbex.run()
        if results == "0":
            STREAM.success(" -> Successfully executed.")
        else:
            raise Exception(" -> Ansible playbook(%s) exited with error_code: %s" % (playbook, results))
        # Clean ansible temp files
        shutil.rmtree(C.DEFAULT_LOCAL_TMP, True)


if __name__ == "__main__":
    pass
